/**
 * @fileoverview Firestore Security Rules for the Coffee Campus application.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for private data (timetables, chat messages, notifications)
 * and a public-read, owner-write model for notices. User data is protected, and only authenticated users can
 * create content, with ownership validated on creation.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only to the owner.
 * - /notices/{noticeId}: Stores public notices, readable by all, but writable only by the author.
 * - /timetables/{userId}: Stores user timetables, accessible only to the owner.
 * - /chat_conversations/{userId}: Stores chat messages, accessible only to the owner.
 * - /users/{userId}/notifications/{notificationId}: Stores user notifications, accessible only to the owner.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Roles are not yet implemented (future enhancement with DBAC).
 * - Data shape validation is relaxed for rapid prototyping.
 *
 * Denormalization for Authorization:
 * - Notices store the authorId directly within the document, avoiding the need for `get()` calls during authorization.
 *
 * Structural Segregation:
 * - Private user data (timetables, chat messages, notifications) is stored under the /users/{userId} path,
 *   while public notices are stored in the top-level /notices collection. This ensures a clear separation
 *   of concerns and simplifies access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @return {boolean} True if the request is authenticated, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the authenticated user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the existing owner of the resource.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the authenticated user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) User 'test_user' with ID matching auth.uid can create their profile.
     * @allow (get) User 'test_user' can read their own profile data.
     * @allow (update) User 'test_user' can update their own profile data.
     * @allow (delete) User 'test_user' can delete their profile.
     * @deny (create) User 'another_user' cannot create a profile with ID 'test_user'.
     * @deny (get) User 'another_user' cannot read the profile data of 'test_user'.
     * @deny (update) User 'another_user' cannot update the profile data of 'test_user'.
     * @deny (delete) User 'another_user' cannot delete the profile of 'test_user'.
     * @principle Enforces document ownership for all operations on user profiles.
     */
    match /users/{userId} {
      // Only the user can read their own profile.
      allow get: if isOwner(userId);
      // User listing is disallowed.
      allow list: if false;

      // A user can create their own profile if the userId matches their auth.uid.
      allow create: if isOwner(userId) && request.resource.data.id == userId;

      // Only the user can update their own profile, and the userId field is immutable.
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;

      // Only the user can delete their own profile.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /notices/{noticeId} collection.
     * @path /notices/{noticeId}
     * @allow (get) Any user can read a notice.
     * @allow (list) Any user can list notices.
     * @allow (create) Authenticated user 'test_user' can create a notice if authorId matches auth.uid.
     * @allow (update) Authenticated user 'test_user' can update a notice if they are the author.
     * @allow (delete) Authenticated user 'test_user' can delete a notice if they are the author.
     * @deny (create) User 'another_user' cannot create a notice with authorId set to 'test_user'.
     * @deny (update) User 'another_user' cannot update a notice authored by 'test_user'.
     * @deny (delete) User 'another_user' cannot delete a notice authored by 'test_user'.
     * @principle Allows public read access while enforcing ownership for write operations.
     */
    match /notices/{noticeId} {
      // Anyone can read notices.
      allow get, list: if true;

      // Only the author can create a notice, and authorId must match the authenticated user's ID.
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;

      // Only the original author can update or delete a notice.  Must verify that the document exists.
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for the /timetables/{userId} collection.
     * @path /timetables/{userId}
     * @allow (create) User 'test_user' can create their timetable if userId matches auth.uid.
     * @allow (get) User 'test_user' can read their own timetable data.
     * @allow (update) User 'test_user' can update their own timetable data.
     * @allow (delete) User 'test_user' can delete their timetable.
     * @deny (create) User 'another_user' cannot create a timetable with userId 'test_user'.
     * @deny (get) User 'another_user' cannot read the timetable data of 'test_user'.
     * @deny (update) User 'another_user' cannot update the timetable data of 'test_user'.
     * @deny (delete) User 'another_user' cannot delete the timetable of 'test_user'.
     * @principle Enforces document ownership for all operations on user timetables.
     */
    match /timetables/{userId} {
      // Only the user can read their own timetable.
      allow get: if isOwner(userId);
      // Only the owner can list their own timetable
      allow list: if isOwner(userId);

      // A user can create their own timetable if the userId matches their auth.uid.
      allow create: if isOwner(userId) && request.resource.data.userId == userId;

      // Only the user can update their own timetable, and the userId field is immutable.
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;

      // Only the user can delete their own timetable.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /chat_conversations/{userId} collection.
     * @path /chat_conversations/{userId}
     * @allow (create) User 'test_user' can create their chat messages if userId matches auth.uid.
     * @allow (get) User 'test_user' can read their own chat messages.
     * @allow (update) User 'test_user' can update their own chat messages.
     * @allow (delete) User 'test_user' can delete their chat messages.
     * @deny (create) User 'another_user' cannot create chat messages with userId 'test_user'.
     * @deny (get) User 'another_user' cannot read the chat messages of 'test_user'.
     * @deny (update) User 'another_user' cannot update the chat messages of 'test_user'.
     * @deny (delete) User 'another_user' cannot delete the chat messages of 'test_user'.
     * @principle Enforces document ownership for all operations on user chat messages.
     */
    match /chat_conversations/{userId} {
      // Only the user can read their own chat messages.
      allow get: if isOwner(userId);
      // Only the owner can list their own chat messages
      allow list: if isOwner(userId);

      // A user can create their own chat messages if the userId matches their auth.uid.
      allow create: if isOwner(userId) && request.resource.data.userId == userId;

      // Only the user can update their own chat messages, and the userId field is immutable.
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;

      // Only the user can delete their own chat messages.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/notifications/{notificationId} collection.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (create) User 'test_user' can create a notification under their user ID.
     * @allow (get) User 'test_user' can read their own notifications.
     * @allow (update) User 'test_user' can update their own notifications.
     * @allow (delete) User 'test_user' can delete their own notifications.
     * @deny (create) User 'another_user' cannot create a notification under 'test_user's ID.
     * @deny (get) User 'another_user' cannot read notifications under 'test_user's ID.
     * @deny (update) User 'another_user' cannot update notifications under 'test_user's ID.
     * @deny (delete) User 'another_user' cannot delete notifications under 'test_user's ID.
     * @principle Enforces strict user-ownership for notifications.
     */
    match /users/{userId}/notifications/{notificationId} {
      // Only the user can read their own notifications.
      allow get: if isOwner(userId);
      // Only the owner can list their own notifications.
      allow list: if isOwner(userId);

      // A user can create a notification if it's under their own user ID.
      allow create: if isOwner(userId) && request.resource.data.userId == userId;

      // Only the user can update their own notifications, and the userId field is immutable.
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;

      // Only the user can delete their own notifications.
      allow delete: if isExistingOwner(userId);
    }
  }
}